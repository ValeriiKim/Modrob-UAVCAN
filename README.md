# ModRob Framework
For now installation instructions only in russian language (the english version will be later...)
## Основные настройки
Проект базируется на следующих основных сущностях:
  * Фреймворк [PlarformIO](https://platformio.org/) для удобства работы с широким спектром микроконтроллеров различных производителей (мы преимущественно используем контроллры семейства STM32).
  * Протокол UAVCAN (его адаптация для шины CAN - libcanard) позволяющий создавать распределённые вычислительные сети из субмодулей (робота), работающие в реальном времени.
  * Библиотеки LL и HAL для создания драйверов для контроллеров STM32.

Все дальнейшие настройки описываются исходя из предположения, что пользователь работает на ОС Linux. Хотя связка VSCode-PlatformIO вполне работоспособна и на ОС Windows. 
## Установка среды разработки (IDE) и первоначальное конфигурирование
Рекомендуется использовать IDE [VSCode](https://code.visualstudio.com/). Это обусловлено тем, что фреймворк PlatformIO хорошо адаптирован для работы с этой средой.
___
Если вы хотите использовать другую среду, вам нужно установить PlatformIO Core (CLI) отдельно (желательно непосредственно в систему). Затем в конкретной среде разработки можно подключить отдельные функции PlatformIO. Если фреймворк прописан в пути, его всегда можно использовать в терминале. 
___

В VScode фреймворк PlatformIO устанавливается через расширения **Extensions**. 
Для начала работы следует скачать этот репозиторий и распаковать его в отдельную директорию. Далее в VSCode нужно открыть только что распакованную папку: File -> Open Folder. 

## Структура проекта

Все ключевые настройки проекта прописаны в файле `platformio.ini`: используемый контроллер, библиотеки, флаги сборки проекта, идентификаторы модулей и т.д.
Назначение директорий проекта:

`docs` - для хранения различных файлов, относящихся к документации, например, рисунков и схем.

`include` - содержит заголовочные файлы для управления конкретным микроконтроллером (пока что часть функций есть только для stm32f103c8t6). Новые файлы для контроля периферии микроконтроллера нужно создавать в этой директории, например `timer3.h` (для ШИМ) или `I2C.h` для управления I2C. Эти заголовочники по сути представляют собой оболочки над библиотеками LL и HAL, хотя весь функционал этих библиотек можно использовать напрямую в приложении. *Тем не менее это не рекомендуется делать, поскольку код, получаемый с использованием LL и HAL получается очень "раздутым" (особенно для HAL)*.

`lib` - содержит библиотеки проекта: `bxcan`, `cQueue`, `libcanard`, `lwrb` и т.д. Все необходимые библиотеки (свои и сторонние) должны располагаться в этой директории, каждая в своей папке в соответствии с инструкцией в `README`, которая находится в этой же папке. 

`src` - в этой директории находится папка `firmwares`, в которой должны располагаться все файлы приложений для конкретных модулей. Также здесь находится `main.cpp` - основной исходник, в котором прописываются прошивки (об этом далее).

`test` - в этой папке располагаются тесты.
## Работа с прошивками модулей
Файлы прошивок находятся в папке `src/firmwares/`, например, `COGN_MODULE.hpp`, `TEST_MODULE.hpp`, `SENSOR_MODULE.hpp`. Чтобы создать новую прошивку необходимо выполнить следующие шаги.

Например, необходимо создать прошивку для модуля, управляющего двигателем постоянного тока (мощность до 30 Вт).
1. В папке `src/firmwares/` создаём файл прошивки, например `DC_30W.hpp`. На этом этапе можно написать минимальный код в файле.
2. В файле `main.cpp` (папка `src/`) подключаем только что созданный файл:
```cpp
#ifdef TEST_MODULE
#include "firmwares/TEST_MODULE.hpp"
#endif

#ifdef COGN_MODULE
#include "firmwares/COGN_MODULE.hpp"
#endif

#ifdef DC_30W
#include "firmwares/DC_30W.hpp" // подключаем файл нашей прошивки
#endif
```
3. В файле `platformio.ini` создаём новое окружение для нашей прошивки:
```ini
...
[env:DC30W_MODULE]
platform = ststm32
board = bluepill_f103c8 # прописываем используемую плату
framework = stm32cube   # выбираем фреймворк для работы с контроллером
monitor_speed = 115200  # опционально для выбора скорости Serial
build_flags =
    ${env.build_flags}  # включаем общие настройки для всех модулей
    -D DC_30W      # эквивалентно #define DC_30W
	-D MODULE_ID=1 # уникальный идентификатор модуля (значение до 127!)

```
4. После этого можно перейти непосредственно к работе с кодом прошивки. Для проверки правильности всех настроек следует попробовать собрать проект. При этом можно сначала собрать уже какую-нибудь готовую прошивку, например `TEST_MODULE.hpp`. При это среда заново проиндексирует все зависимости, подключит новое окружение. Затем можно уже собирать новую прошивку.  

## Ограничения и замечания

Большая часть субмодулей (по крайней мере в настоящий момент) строится на базе микроконтроллера STM32F103C8T6 (плата Bluepill). 

**Аппаратные ограничения (Hardware restrictions)**:

Для работы с шиной CAN зарезервированы следующие порты (**их нельзя использовать для других целей!**)
 * CANRX - PB8 (45)
 * CANTX - PB9 (46)

Для отладки контроллеров с помощью интерфейса UART (Serial) на скорости 115200 бод/с зарезервированы эти порты:
 * RX2 - PA3 (13)
 * TX2 - PA2 (12)

**Программные ограничения (Software restrictions)**

 * Канал 7 DMA занят для отправки данных из памяти в буфер передачи (TX) UART.
 * Таймер 2 (timer2) используется как главный счётчик времени контроллера, его нельзя использовать для других целей.

